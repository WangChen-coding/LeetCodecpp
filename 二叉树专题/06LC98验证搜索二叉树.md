递归方法，将递归的中序遍历修改为本题的解法

```cpp
class Solution {
public:
	long pre = LONG_MIN;
	bool isValidBST(TreeNode* root) {
		if (root == NULL)return true;
		bool isLeftBst = isValidBST(root->left);
		if (!isLeftBst) {
			return false;
		}
		if (root->val <= pre) {
			return false;
		}
		else {
			pre = root->val;
		}
		return isValidBST(root->right);
	}
};
```

创建一个整数最小值的变量，中序遍历的第一个数要大于这个数。

先遍历左树，将左树的结果输出，若左树是二叉搜索树，那么就继续向右判断。得到当前的值与上一次的值比较，如果当前的值小于上一次的值，说明中序遍历不是升序的，这棵树不是二叉搜索树。若当前的值大于上一次的值，就更新这个pre的值，确保每次递归的过程pre的值都是上一次的值。最终若右树也是bst，那么整颗树就是bst。

非递归方法

```cpp
class Solution {
public:
	long pre = LONG_MIN;
	bool isValidBST(TreeNode* root) {
		stack<TreeNode*>st;
		if (root != NULL) {
			while (!st.empty() || root != NULL) {
				if (root != NULL) {
					st.push(root);
					root = root->left;
				}
				else {
					root = st.top();
					st.pop();
					if (root->val <= pre) {
						return false;
					}
					else {
						pre = root->val;
					}
					root = root->right;
				}
			}
		}
		return true;
	}
};
```

奇怪的一个地方就是 当重新定义root的时候会出错，当然确实没有必要重新定义它`TreeNode* root = st.top();`

