https://leetcode-cn.com/problems/minimum-path-sum/submissions/



给定一个二维数组matrix，一个人必须从左上角出发，最后到达右下角

沿途只可以向下或者向右走，沿途的数字都累加就是距离累加和

返回最小距离累加和



### 动态规划

建立一个dp表，i和j表示ij位置到00的最小路径和，题目中求的是00到右下角的最小路径和。

最终要求的就是row-1和col-1位置的值。

首先分析basecase

第一行的dp值，通过累加就可以得到。

同理，第一列的值，通过累加也可以得到。

普遍位置的值，取上和左中的最小值再加上当前矩阵对应位置的值就可以得出。

```cpp
int minPathSum1(vector<vector<int>>& m) {
    if (m.size() == 0 || m[0].size() == 0) {
        return 0;
    }
    int row = m.size();
    int col = m[0].size();
    vector<vector<int>>dp(row, vector<int>(col, 0));
    dp[0][0] = m[0][0];
    for (int i = 1; i < row; i++) {
        dp[i][0] = m[i][0] + dp[i - 1][0];
    }
    for (int j = 1; j < col; j++) {
        dp[0][j] = m[0][j] + dp[0][j - 1];
    }
    for (int i = 1; i < row; i++) {
        for (int j = 1; j < col; j++) {
            dp[i][j] = m[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
        }
    }
    return dp[row - 1][col - 1];
}
```

### 压缩数组

减少dp表的空间占用，用一个数组代替整个dp表，

```cpp
int minPathSum2(vector<vector<int>>& m) {
    if (m.size() == 0 || m[0].size() == 0) {
        return 0;
    }
    int row = m.size();
    int col = m[0].size();
    vector<int>dp(col,0);
    dp[0] = m[0][0];
    for (int j = 1; j < col; j++) {
        dp[j] = dp[j - 1] + m[0][j];
    }
    for (int i = 1; i < row; i++) {
        dp[0] = m[i][0] + dp[0];
        for (int j = 1; j < col; j++) {
            dp[j] = min(dp[j - 1], dp[j]) + m[i][j];
        }
    }
    return dp[col - 1];
}
```

优化：
如果用与矩阵等规模的dp表来存储子问题，会浪费空间
一个位置的dp只依赖上面和左边的dp值

可以弄两个数组，A数组储存dp表中的第一行元素，根据第一行的元素计算第二行的元素存放在B中，然后将A中的元素释放掉，将计算得到的第三行元素的值放在A中，不断向下推进

再优化：

一个数组就够了，第一行的元素用数组表示，然后自我更新，更新为第二行的元素。

a‘不需要左边的元素，只需上面的元素，直接替换数组中a的位置，

b’要求a‘和b的值。正好是前面位置已经更新完成的值和当前位置上没有更新的值。两者取最小值加上这个位置的值，当前位置更新完成。

### 数组压缩推广

下次再遇到一个动态规划，依赖左边依赖上面，都可以这样操作

那如果依赖左上角和上面两个位置，这种问题第0行的元素必然是已知的，因为他既没有左上也没上。

从右往左求可以搞定，每行的0号元素不存在左上，所以只靠上方元素即可

 

如果依赖上、左和左上，

第0行，没有左上也没有上，只能依赖自己左边

填第二行的时候，先用一个变量记录原先a位置的元素，再更新a位置。此时变量的值为原先左上角的值，左边的值是左边的值，当前的值是上面的值，更新之前，将变量的值更新为之前的值。

 

如果列数比较小，就一行一行更新

如果行数比较少，就一列一列更新

 

空间会得到很大简化

这种就是使用一维数组来解决二维的动态规划