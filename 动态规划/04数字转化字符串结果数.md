### 题目 数字转化字符串的最多结果数

规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 

### 暴力递归：从左到右的尝试模型



#### 自己思考时存在的一些问题

1. 对于一个字符串类型的数据，如何确定选择位置的index。
2. 如果选择的是两位数字的情况，如何判断是否在正确范围之内。
3. 如果不在正确范围之内，如何处理这种情况。
4. 这个问题的解法为什么是相加，而背包最大价值问题是选其中一个最大的max。

#### 解答

1. string类型变量依然可以通过下标运算法来访问和管理
2. 选择两位数，首先要确定有两位数可以选，即下一位不超过str 的长度；另外就是两位数组合起来要小于27，即满足字母的要求
3. 如果两位数的选择行不通，那么就不会选两位数这条路，直接跳过进入下一次递归。（简单地说就是，如果两条路的可行，那么就再加一个递归路径，如果不可行，那么就没有这条递归路径）
4. 背包问题存在选和不选两条路，都可以执行。而当前问题，是问有多少种转换方法，
5. 自己考虑的时候还少考虑了一种情况，就是如果index位置是以0开始的，那么说明之前的选择是错误的，无法完成转换任务，直接返回0，结束这条递归路径。

#### 题目整体思路

构建尝试函数，str为数字字符串，index为当前进行到哪个位置，返回值为当前转换结果数

主函数中如何调用？ 在主函数中调用process(str,index)

分析basecase

当index==str的长度时，到达字符串的尾部，返回数字1，表示找到一种转换结果

分析普通情况

当index遇到的字符为0，因为没有以0开始的数字串对应的字母，则说明之前选择是错误的，直接返回0。

若index遇到的字符是3-9，直接读取一位

若index遇到的是1-2的时候，可以选一位，也可以选两位，选择两位的时候要判断是否在10到26之间

总结一下：

当index遇到0 直接返回0表示之前做的决定是错误的

index选择一位的情况

index选择两位的情况，需要判断下一位是否存在并且两位的值应该小于27，若满足条件，则可以继续。

```cpp
int process(string& str, int index) {
    if (index == str.size()) {
        return 1;
    }
    if (str[index] == '0') {
        return 0;
    }
    int p1 = process(str, index + 1);
    if (index + 1 < str.size() && ((str[index] - 'a') * 10 + str[index + 1] - 'a') < 27) {
        p1 += process(str, index + 2);
    }
    return p1;
}
int way1(string& str) {
    return process(str, 0);
}
```

### 动态规划

分析可变参数，只有一个index，变化范围是0到N，所以建一张dp表长度为N+1

要求的位置是0位置的值

分析basecase：当index=N的时候，值为1

普遍依赖情况是依赖下一个位置或下两个位置的和。

```cpp
int way2(string& str) {
	int N = str.size();
	vector<int>dp(N+1, 0);
	dp[N] = 1;
	for (int index = N - 1; index >= 0; index--) {
		if (str[index] != '0') {
			int p1 = dp[index + 1];
			if (index + 1 < str.size() && ((str[index] - 'a') * 10 + str[index + 1] - 'a') < 27) {
				p1 += dp[index + 2];
			}
			dp[index] = p1;
		}
	}
	return dp[0];
}
```

