规定1和A对应、2和B对应、3和C对应...26和Z对应
那么一个数字字符串比如"111”就可以转化为:
"AAA"、"KA"和"AK"
给定一个只有数字字符组成的字符串str，返回有多少种转化结果 



### 暴力递归

构建尝试函数，str为数字字符串，index为当前进行到哪个位置，返回值为当前转换结果数

主函数中如何调用process(str,index)

分析basecase

当index==str的长度时，到达字符串的尾部，返回数字1，表示找到一种转换结果

分析普通情况

当index遇到的字符为0，因为没有以0开始的数字串对应的字母，则说明之前选择是错误的，直接返回0。

若index遇到的字符是3-9，直接读取一位

若index遇到的是1-2的时候，可以选一位，也可以选两位，选择两位的时候要判断是否在10到26之间

总结一下：

当index遇到0 直接返回0表示之前做的决定是错误的

index选择一位的情况

index选择两位的情况，需要判断下一位是否存在并且两位的值应该小于27，若满足条件，则可以继续。

```cpp
int process(string& str, int index) {
    if (index == str.size()) {
        return 1;
    }
    if (str[index] == '0') {
        return 0;
    }
    int p1 = process(str, index + 1);
    if (index + 1 < str.size() && ((str[index] - 'a') * 10 + str[index + 1] - 'a') < 27) {
        p1 += process(str, index + 2);
    }
    return p1;
}
int way1(string& str) {
    return process(str, 0);
}
```

### 动态规划

分析可变参数，只有一个index，变化范围是0到N，所以建一张dp表长度为N+1

要求的位置是0位置的值

分析basecase：当index=N的时候，值为1

普遍依赖情况是依赖下一个位置或下两个位置的和。

```cpp
int way2(string& str) {
	int N = str.size();
	vector<int>dp(N+1, 0);
	dp[N] = 1;
	for (int index = N - 1; index >= 0; index--) {
		if (str[index] != '0') {
			int p1 = dp[index + 1];
			if (index + 1 < str.size() && ((str[index] - 'a') * 10 + str[index + 1] - 'a') < 27) {
				p1 += dp[index + 2];
			}
			dp[index] = p1;
		}
	}
	return dp[0];
}
```

